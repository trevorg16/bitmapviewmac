#include <MacWindows.h>//#include <Quickdraw.h>#include <Events.h>#include <Dialogs.h>#include <ToolUtils.h>#include <Sound.h>#include <string.h>#include <stdio.h>#include <stdlib.h>#include <TextUtils.h>#include <TextEdit.h>#include <ctype.h>#include <StandardFile.h>#include <Files.h>#include <Endian.h>#include <QDOffscreen.h>#include <LowMem.h>//#include "simple_string.h"#include "modint.h"// constantsconst short defaultMenubar = 128;const short menuApple = 128;const short menuFile = 129;const short menuitemAbout = 1;const short menuitemOpen = 1;const short menuitemClose = 2;const short menuitemQuit = 3;const short imageWindow = 128;const short LogWindow = 129;const short boxSize = 75;#define PATHLEN 255#define LOGLINES 100#define LOGLEN 256#define LOGWINDOWTYPE 0#define BITMAPWINDOWTYPE 1#define CHUNK_SIZE 2048#define MIN(a,b) (((a)<(b))?(a):(b))#define MAX(a,b) (((a)>(b))?(a):(b))#define BUF_SIZE 2048// globals#if __MWERKS__ == 0QDGlobals qd;#endif//Log window classclass LogWindowData {		WindowPtr window;		//Rect dimensions;		TEHandle textEdit;	public:		LogWindowData(WindowPtr window);		~LogWindowData();		void log(char* line);		void setup();		void redraw();};LogWindowData::LogWindowData(WindowPtr window) {	this->window = window;		}void LogWindowData::setup(){	Rect txRect = window->portRect;	textEdit = TENew(&txRect, &txRect);	TEAutoView(true, textEdit);}LogWindowData::~LogWindowData() {	TEDispose(textEdit);}void LogWindowData::log(char* line){	WindowPtr orig_win;	GetPort(&orig_win);	TEInsert(line, strlen(line), textEdit);	TEKey('\n', textEdit);	SetPort(orig_win);}void LogWindowData::redraw(){	WindowPtr orig_win;	GetPort(&orig_win);	SetPort(this->window);		Rect* txRect = &(window->portRect);	//char toLog[100];	//sprintf(toLog, "T:%d,L:%d,B:%d,R:%d", txRect.top, txRect.left, txRect.bottom, txRect.right);	//this->log(toLog);	EraseRect(txRect);	TEUpdate(txRect, textEdit);	//TESetText(str.c_str(), str.len(), textEdit);	//EraseRect(	SetPort(orig_win);}LogWindowData* gLogWindowData;//Data structure to discriminate the type of the windowclass WindowData {		void* dataVal;		uint8_t wtype;	public:		WindowData(uint8_t  wtype, void* dataVal){			this->dataVal = dataVal;			this->wtype = wtype;		}		bool_t isLogWindow(){			return (wtype == LOGWINDOWTYPE);		}				void* getData(){			//char toLog[100];			//sprintf(toLog, "getDatat returning: %p", dataVal);			//gLogWindowData->log(toLog);			return dataVal;		}};struct BitmapHeader {	//Header	uint16_t signature;	uint32_t file_size;	//uint32_t res1;	uint32_t data_offset;	//InfoHeader	uint32_t size_infohdr;	uint32_t width;	uint32_t height;	uint16_t planes;	uint16_t bits_per_pixel;	uint32_t compression;	uint32_t image_size;//Compressed size	uint32_t x_ppm;	uint32_t y_ppm;	uint32_t colours_used;	uint32_t important_colours;};//BitmapImg classclass BitmapImg {public:    BitmapImg(FSSpec file_path_spec, WindowPtr window);	~BitmapImg();		//bool_t img_loaded = 0;	    //uint8_t* img_data = NULL;	uint8_t* img_data;	bool_t isGood();	void drawImage();private:	//char filename[PATHLEN];	//FSSpec file_path;	short refNum;	bool_t goodFile;	BitmapHeader hdr;	bool_t parseHeader(uint8_t* raw_hdr);	bool_t readFileData();	CWindowPtr window;	bool_t newWorldAllocated;	//GWorldPtr offscreenGWorld;		GWorldPtr offscreen;	PixMapHandle offPixMapHandle;		int fillBuf(uint8_t* buf);};bool_t BitmapImg::isGood(){	return goodFile;}bool_t BitmapImg::parseHeader(uint8_t* raw_hdr){	char toLog[256];	//Header is guaranteed to be 54 bytes	hdr.signature = (*((uint16_t*)(raw_hdr)));	hdr.file_size = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 2)));	hdr.data_offset = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0xA)));		hdr.size_infohdr = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0xE)));	hdr.width = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x12)));	hdr.height = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x16)));		hdr.planes = EndianU16_LtoN(*((uint16_t*)(raw_hdr + 0x1A)));	hdr.bits_per_pixel = EndianU16_LtoN(*((uint16_t*)(raw_hdr + 0x1C)));		hdr.compression = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x1E)));	hdr.image_size = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x22)));		hdr.x_ppm = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x26)));	hdr.y_ppm = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x2A)));		hdr.colours_used = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x2E)));		hdr.important_colours = EndianU32_LtoN(*((uint32_t*)(raw_hdr + 0x32)));		sprintf(toLog, "Sig: %d, fs: %d, do: %d, sz_info: %d, width: %d, height: %d, planes: %d, bpp: %d, compression: %d, img_sz: %d, x_ppm: %d, y_ppm: %d, colours: %d, imp_colours: %d",	hdr.signature, hdr.file_size, hdr.data_offset, hdr.size_infohdr, hdr.width, hdr.height, hdr.planes, 	hdr.bits_per_pixel, hdr.compression, hdr.image_size, hdr.x_ppm, hdr.y_ppm, hdr.colours_used, hdr.important_colours);	gLogWindowData->log(toLog);		return true;}BitmapImg::~BitmapImg(){	if(newWorldAllocated){		gLogWindowData->log("Disposing G world");		DisposeGWorld(offscreen);	}}void BitmapImg::drawImage(){		if(! newWorldAllocated){		return;	}	if(! LockPixels(offPixMapHandle)){		gLogWindowData->log("draw Failed to lock pixels");		return;	}	GrafPtr origPort;		GetPort(&origPort);	SetPort((GrafPtr)window);	gLogWindowData->log("Running drawImage");	EraseRect(&(window->portRect));		Rect sourceRect = offscreen->portRect;	Rect destRect = window->portRect;	BitMap* destBits = (BitMap*)*(window->portPixMap);	CopyBits((BitMap*)*(offscreen->portPixMap), destBits, &sourceRect, &destRect, srcCopy, NULL);	UnlockPixels(offPixMapHandle);	gLogWindowData->log("Copied bits");	SetPort(origPort);}int BitmapImg::fillBuf(uint8_t* buf){	long readSz = BUF_SIZE;	OSErr err = FSRead(refNum, &readSz, buf);	if(err){		return -1;	}	return readSz;}bool_t BitmapImg::readFileData(){	char toLog[100];	SizeWindow((WindowPtr)window, hdr.width, hdr.height, true);		short bitDepth = (**(window->portPixMap)).pixelSize;	sprintf(toLog, "bit depth: %d", bitDepth);	gLogWindowData->log(toLog);	Size img_size =  (hdr.width * hdr.height) * bitDepth;	unsigned long freeSpace = CompactMem(img_size);	if(freeSpace < img_size){		SysBeep(1);		gLogWindowData->log("Insufficient space after Compaction");		return false;	}	else{		gLogWindowData->log("Space sufficient.");	}				//Rect imageSizeRect = {0,0, hdr.height, hdr.width};	//Rect imageSizeRect = {0,0, hdr.width, hdr.height};	Rect imageSizeRect = ((WindowPtr)window)->portRect;	sprintf(toLog, "imageSizeRect: {T:%d,L:%d,B:%d,R:%d}", imageSizeRect.top, imageSizeRect.left, imageSizeRect.bottom, imageSizeRect.right);	gLogWindowData->log(toLog);		CGrafPtr origPort;	GDHandle origDev;		GetGWorld(&origPort, &origDev);		QDErr err = NewGWorld(&offscreen, 0, &imageSizeRect, NULL, NULL, 0);	sprintf(toLog, "NewGWorld: %d", err);	gLogWindowData->log(toLog);	if(err){		SetGWorld(origPort, origDev);		SysBeep(1);		gLogWindowData->log("Allocation actually failed");		return false;	}	newWorldAllocated = true;		SetGWorld(offscreen, NULL);		offPixMapHandle = GetGWorldPixMap(offscreen);	if(! LockPixels(offPixMapHandle)){		SetGWorld(origPort, origDev);		gLogWindowData->log("Failed to lock pixels");		SysBeep(1);		return false;	}	EraseRect(&(offscreen->portRect));		Size huge_read_size = hdr.file_size - hdr.data_offset;	//This is a test section	SetFPos(refNum, fsFromStart, hdr.data_offset);	Handle buf_handle = NewHandle(huge_read_size);	if(buf_handle == NULL){		SetGWorld(origPort, origDev);		gLogWindowData->log("Handle allocation failed");		goto fail_draw;	}	HLock(buf_handle);	uint8_t* buf;	buf = (uint8_t*)*buf_handle;		OSErr readErr;	readErr = FSRead(refNum, &huge_read_size, buf);	if(readErr || (huge_read_size != (hdr.file_size - hdr.data_offset))){		SetGWorld(origPort, origDev);		gLogWindowData->log("failed to do huge read");		goto fail_draw;	}		int a;	unsigned int alignment;	alignment = 0;	int first_10;	first_10 = 0;	for(a = 0; a < hdr.height; a++){		uint8_t* ptr;		uint8_t* line_start_p;		//line_start_p = 3*(hdr.width * a) + buf + alignment;		for(int b = 0; b < hdr.width; b++){			ptr = 3*(b + (hdr.width * a)) + buf + alignment;			RGBColor colo;			//colo.red = buf[3*(a*b) + 0] << 8;			//colo.blue = buf[3*(a*b) + 1] << 8;			//colo.green = buf[3*(a*b) + 2] << 8;			colo.blue = *ptr << 8;			colo.green = *(ptr+1) << 8;			colo.red = *(ptr + 2) << 8;			SetCPixel(b, hdr.height - a - 1, &colo);			/*if(first_10 < 10 && a == 10){				//SetCPixel(b, hdr.height - a - 1, &colo);				//sprintf(toLog, "px %d: (R:%d,G:%d,B:%d)", first_10, *(ptr+2), *(ptr+1), *ptr);				sprintf(toLog, "px %d: (R:%x,G:%x,B:%x)@%p", first_10, colo.red, colo.green, colo.blue, ptr - buf + hdr.data_offset);				CGrafPtr restorePort;				GDHandle restoreDev;				GetGWorld(&restorePort, &restoreDev);				SetGWorld(origPort, origDev);				gLogWindowData->log(toLog);				//gLogWindowData->log("Test!");				SetGWorld(restorePort, restoreDev);				first_10++;			}*/		}		/*		unsigned int line_len = ptr - buf;		uint8_t remainder = line_len & 0x3;		if(remainder != 0){			sprintf(toLog, "align ptf - buf: %x, rem: %x, offset: %x", line_len, remainder, 4 - remainder);			alignment += 4 - remainder;						CGrafPtr restorePort;			GDHandle restoreDev;			GetGWorld(&restorePort, &restoreDev);			SetGWorld(origPort, origDev);			gLogWindowData->log(toLog);			SetGWorld(restorePort, restoreDev);		}*/		uint8_t align_chk = ((unsigned long)(ptr - buf + hdr.data_offset + 1)) & 0x3;		if(align_chk != 0){			alignment += 4 - align_chk;			/*			CGrafPtr restorePort;			GDHandle restoreDev;			GetGWorld(&restorePort, &restoreDev);			SetGWorld(origPort, origDev);			gLogWindowData->log("Had to skip");			SetGWorld(restorePort, restoreDev);			*/		}	}	HUnlock(buf_handle);	DisposeHandle(buf_handle);			//goto fail_draw;	//End test section/*	SetFPos(refNum, fsFromStart, hdr.data_offset);	long realPos = 0;	long pos = 0;	uint8_t buf[BUF_SIZE];	long remaining = fillBuf(buf);	for(int i = 0; i < hdr.height; i++){		for(int j = 0; j < hdr.width; j++){			RGBColor colo;			if(remaining <= 3){				int was_remaining = remaining;				switch(remaining){					case 3:						colo.blue = buf[pos + 2] << 8;					case 2:						colo.green = buf[pos + 1] << 8;					case 1:						colo.red = buf[pos] << 8;					default:						remaining = fillBuf(buf);						pos = 0;						if(remaining <= 0){							gLogWindowData->log("Fail to read 1");							goto fail_draw;						}				}				if(remaining > 0){					switch(was_remaining){						case 0:							colo.red = buf[pos] << 8;						case 1:							colo.green = buf[pos + 1] << 8;						case 2:							colo.blue = buf[pos + 2] << 8;						default:							break;					}				}			}			else{				colo.red = buf[pos] << 8;				colo.green = buf[pos + 1] << 8;				colo.blue = buf[pos + 2] << 8;				//colo.red = colo.green = colo.blue = 0xffff;			}			remaining -= 3;			pos += 3;			realPos += 3;			//colo.red = 0xdd6b;			//colo.green = 0x8c2;			//colo.blue = 0x6a2;			//RGBForeColor(&colo);			//MoveTo(i,j);			//Line(1,0);			SetCPixel(j, i, &colo);		}		int needToShift = realPos % 4;		//if(needToShift > 0){		//	pos += 4 - needToShift;		// I think we need a remaining decrement here		//}		if(remaining <= 0){			remaining = fillBuf(buf);			pos = 0;			if(remaining <= 0){				gLogWindowData->log("Fail to read 2");				goto fail_draw;			}		}	}	//MoveTo(0,0);*/fail_draw:		SetGWorld(origPort, origDev);	UnlockPixels(offPixMapHandle);		gLogWindowData->log("Read complete");}BitmapImg::BitmapImg(FSSpec file_path_spec, WindowPtr window){	//strncpy(filename, file_path, PATHLEN);	//img_data = NULL;	//this->file_path = file_path;	//this->goodFile = false;//Assume the file will not load successfully	this->window = (CWindowPtr)window;	goodFile = false;	newWorldAllocated = false;	char toLog[100];	char* logMsg = "Opening: ";	strcpy(toLog, logMsg);	p2cstrcpy(toLog + strlen(logMsg), file_path_spec.name);	gLogWindowData->log(toLog);			OSErr err = FSpOpenDF(&(file_path_spec), fsRdPerm, &refNum);	if(err){		sprintf(toLog, "Failed to open file. Err: %d", err);		gLogWindowData->log(toLog);		return;	}	const long hdr_size = 54;	int num_retries = 10;	uint8_t raw_hdr[hdr_size];		long numBytesRemaining =  hdr_size;	long numBytes = hdr_size;	while(numBytesRemaining > 0 && num_retries > 0){		err = FSRead(refNum, &numBytes, raw_hdr);		if(err){			sprintf(toLog, "Failed to read hdr. Err: %d", err);			gLogWindowData->log(toLog);			goto fail_load_bitmap_close;		}			numBytesRemaining -= numBytes;		numBytes = numBytesRemaining;		num_retries--;	}	if(num_retries == 0 && numBytesRemaining > 0){		gLogWindowData->log("Failed to read file. Timeout.");		goto fail_load_bitmap_close;	}	goodFile = true;	gLogWindowData->log("Successfully read header");		parseHeader(raw_hdr);	readFileData();	drawImage();	//gLogWindowData->redraw();	fail_load_bitmap_close:	FSClose(refNum);	}// function prototypesvoid Initialize();void MainLoop();void Terminate();void doMenuBar(long menuAction);void doClick(WindowPtr window, Point where);void drawWindow(WindowPtr window);void drawLogWindow();void openfile();void closeWindow(WindowPtr window);void openWindow();void main() {    Initialize();    MainLoop();    Terminate();}// Initializevoid Initialize() {	//SetApplLimit((Ptr) GetApplLimit() - 100000L);	MaxApplZone();    InitGraf(&qd.thePort);    InitFonts();    InitWindows();    InitMenus();    TEInit();    InitDialogs(nil);    InitCursor();			FlushEvents(everyEvent, 0);    Handle menubar = GetNewMBar(defaultMenubar);    SetMenuBar(menubar);    DrawMenuBar();		drawLogWindow();		}void MainLoop() {    EventRecord event;    while (true) {        if (WaitNextEvent(everyEvent, &event, 10L, nil)) {            if (event.what == mouseDown) {                WindowPtr clickedWindow;                short clickedPart = FindWindow(event.where, &clickedWindow);                if (clickedPart == inMenuBar) {                    doMenuBar(MenuSelect(event.where));                } else if (clickedPart == inDrag) {                    DragWindow(clickedWindow, event.where, &qd.screenBits.bounds);                } else if (clickedPart == inGoAway) {                    if (TrackGoAway(clickedWindow, event.where)) {						closeWindow(clickedWindow);                    }                } else if (clickedPart == inContent) {                    if (clickedWindow != FrontWindow()) {                        SelectWindow(clickedWindow);                        //drawWindow(clickedWindow);                    } else {                        doClick(clickedWindow, event.where);                    }                }            } 			else if (event.what == updateEvt) {                BeginUpdate((WindowPtr) event.message);                drawWindow((WindowPtr) event.message);                EndUpdate((WindowPtr) event.message);            }			else if (event.what == keyDown) {				if(((event.modifiers & cmdKey) != 0)){					//LogWindowData* logdata;					//WindowPtr window = GetNewWindow(LogWindow, nil, (WindowPtr) -1);					//char name[25] = "\pThis is a test.";					//										//char c_name[25];					//Str255 name;					char charPressed = tolower(LoWord(event.message));					if(charPressed == 'o'){						HiliteMenu(menuFile);						openfile();						HiliteMenu(0);					}					else if(charPressed == 'q'){						HiliteMenu(menuFile);						Terminate();						HiliteMenu(0);					}					else if(charPressed == 'w'){						HiliteMenu(menuFile);						WindowPtr activeWindow;						//FindWindow(event.where, &activeWindow);//This finds where the mouse is						//GetPort(&activeWindow);//Causes issues sometimes						activeWindow = FrontWindow();						closeWindow(activeWindow);						HiliteMenu(0);					}					else if(charPressed == 'l'){						gLogWindowData->log("Command-L key pressed");					}					//sprintf(c_name, "Win: %d", charPressed);					//c2pstrcpy(name, c_name);					//Str255 name = "\pBitmap View Log";					//SetWTitle(window, name);					//logdata = new LogWindowData();					//SetWRefCon(window, (long) logdata);					//char keyPress = (0xFF00 & LoWord(event.what)) >> 8;					//if(keyPress == 'O' || keyPress == 'o'){											//}				}			}        }    }}void Terminate() {	//gLogWindowData->log("We would terminate");    ExitToShell();}void drawLogWindow(){	//LogWindowData* logdata;	WindowData* windata;	WindowPtr window;		window = GetNewCWindow(LogWindow, nil, (WindowPtr) -1);	Str255 name = "\pBitmap View Log";	SetWTitle(window, name);		gLogWindowData = new LogWindowData(window);	windata = new WindowData(LOGWINDOWTYPE, gLogWindowData);	SetWRefCon(window, (long) windata);		SetPort(window);	gLogWindowData->setup();}void drawWindow(WindowPtr window) {    WindowData* windata = (WindowData*) GetWRefCon(window);	if(windata->isLogWindow()){		LogWindowData* lwd = windata->getData();		lwd->redraw();	}	else{		BitmapImg* imgData = (BitmapImg*) windata->getData();		imgData->drawImage();	}	//gLogWindowData->log("UPDATE");    SetPort(window);}void doClick(WindowPtr window, Point where) {	//return;	WindowData* pWinData = (WindowData*)GetWRefCon(window);	if(pWinData == nil){		return;	}	if(! pWinData->isLogWindow()){		SysBeep(1);	}}void closeWindow(WindowPtr window){	//Todo: Check the type of the window which has been closed	//Set a global variable for the 'log' window and terminate when that is clicked		if(window == nil){		gLogWindowData->log("Would close nil window!");		return;	}		WindowData* pWinData = (WindowData*)GetWRefCon(window);	if(pWinData == nil){		DisposeWindow(window);		return;	}	//if(false){	if(pWinData->isLogWindow()){		//LogWindowData* logData = (LogWindowData*) pWinData->getData();		//delete logData;		//Terminate();				gLogWindowData->log("Close Log attempt");	}	else{		BitmapImg* imgData = (BitmapImg*) pWinData->getData();		gLogWindowData->log("Close image");		//if(imgData == nil){		char* initial_str = "imgdata is:";		char toLog[100];		sprintf(toLog, "%s %p", initial_str, imgData);		gLogWindowData->log(toLog);		//}		delete imgData;		delete pWinData;			DisposeWindow(window);		gLogWindowData->log("Disposed");	}	}void openfile(){	//gLogWindowData->log("Openfile");		StandardFileReply stdReply;	SFTypeList theTypeList = {'BMPf', 0, 0, 0};		StandardGetFile(NULL, 1, theTypeList, &stdReply);	if(stdReply.sfGood){		WindowPtr window = GetNewCWindow(imageWindow, nil, (WindowPtr) -1);		//Str255 name = "\pBitmap Image";		SetWTitle(window, stdReply.sfFile.name);		CGrafPtr w;		BitmapImg* img = new BitmapImg(stdReply.sfFile, window);		//char toLog[100];		//sprintf(toLog, "img allocated at %p", img);		//gLogWindowData->log(toLog);		WindowData* windata = new WindowData(BITMAPWINDOWTYPE, img);		SetWRefCon(window, (long) windata);		SelectWindow(window);		//SetPort(window);	}	else{		gLogWindowData->log("File open failed");	}	}void doMenuBar(long menuAction) {    if (menuAction <= 0) {        return;    }    short menu = HiWord(menuAction);    short item = LoWord(menuAction);    if (menu == menuApple) {        if (item == menuitemAbout) {            SysBeep(1);        }    } else if (menu == menuFile) {        if (item == menuitemOpen) {			openfile();        } else if (item == menuitemQuit) {            Terminate();        }		else if (item == menuitemClose){			WindowPtr activeWindow;			GetPort(&activeWindow);			closeWindow(activeWindow);		}    }    HiliteMenu(0);}